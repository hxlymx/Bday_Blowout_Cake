

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Birthday AQ!</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Custom styles for the 3D canvas and effects */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark theme background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none; /* Prevents unwanted mobile scrolling */
        }
        #scene-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        /* Style for the central instruction message */
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            color: white;
            padding: 1.5rem;
            border-radius: 1rem;
            text-align: center;
            max-width: 90%;
            pointer-events: none; /* Allows clicks/taps to pass through if needed */
        }
        /* Specific styles for the flame glow and candle glitter */
        .candle-flame {
            /* This is a visual reference, the actual flames are Three.js objects */
        }
        .glitter-text {
            /* Gold gradient for a glittery look on the instruction/message text */
            background: linear-gradient(145deg, #FFD700, #F0E68C, #DAA520, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 200% 200%;
            animation: shimmer 5s ease infinite;
        }
        @keyframes shimmer {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Birthday message styles for animation */
        #birthday-message {
            opacity: 0;
            transform: scale(0.8) translateY(20px);
            transition: opacity 1s ease-out, transform 1s ease-out;
        }
        #birthday-message.active {
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        /* Loading indicator styles */
        .loading-dot {
            animation: pulse 1s infinite;
        }
        .loading-dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>

    <!-- Three.js Scene Container -->
    <div id="scene-container"></div>

    <!-- Instructions and Message Overlay -->
    <div id="message-box" class="bg-black/50 backdrop-blur-sm shadow-2xl transition duration-500">
        <div id="initial-instruction" class="text-xl">
            <p class="mb-4 text-gray-300">Tap to light the candles and enable the microphone!</p>
            <div id="mic-status" class="text-sm text-yellow-400">
                <span id="loading-dots">
                    <span class="loading-dot">.</span><span class="loading-dot">.</span><span class="loading-dot">.</span>
                </span>
                Waiting for interaction...
            </div>
            <p class="mt-4 text-3xl font-extrabold glitter-text">Happy Birthday AQ!</p>
        </div>

        <div id="birthday-message" class="hidden">
            <h2 class="text-6xl font-black mb-2 glitter-text">HOORAY!</h2>
            <p class="text-2xl text-white">Make a wish come true!</p>
        </div>
    </div>

    <script type="module">
        // --- MANDATORY FIREBASE SETUP (Included but not used for this client-side game) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Globals (Mandatory)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth;

        // Initialize Firebase services (we still need to initialize them as per instructions)
        if (Object.keys(firebaseConfig).length > 0) {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            setLogLevel('Debug'); // Enable logging for debugging

            // Authentication logic
            async function authenticate() {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                    console.log("Firebase Auth successful.");
                } catch (error) {
                    console.error("Firebase Auth failed:", error);
                }
            }
            authenticate();
        } else {
            console.warn("Firebase configuration not found. Skipping initialization.");
        }
        // --- END OF MANDATORY FIREBASE SETUP ---

        // =========================================================================
        // THREE.JS AND GAME LOGIC
        // =========================================================================

        let scene, camera, renderer, candles = [], flames = [], lights = [];
        let confettiParticles, sparklerParticles;
        let isCandleLit = false;
        let hasBlownOut = false;

        // Audio Input Variables
        let audioContext, analyser, microphone, stream;
        const BLOW_THRESHOLD = 150; // Threshold for volume detection (0-255)

        // Configuration
        const CAKE_COLORS = {
            darkChocolate: 0x4a2a1a,
            icingWhite: 0xf0f0f0,
            plateWhite: 0xffffff,
            candleGold: 0xffd700,
            flamePurple: 0x8a2be2,
            sprinkleRed: 0xff0000,
            sprinkleBlue: 0x0000ff
        };

        const CANDLE_POSITIONS = [
            { x: -0.6, z: 0.3 }, // Position for 'A'
            { x: 0.6, z: 0.3 }  // Position for 'Q'
        ];

        // --- Initialization ---

        function initScene() {
            const container = document.getElementById('scene-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera (Mobile-friendly perspective)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 12);
            camera.lookAt(0, 4, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lighting
            addLighting();

            // Cake and Candles
            createCake();
            createCandles();

            // Sparkler and Confetti (Initialised but invisible)
            createParticles();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            container.addEventListener('touchstart', startInteraction, { once: true });
            container.addEventListener('click', startInteraction, { once: true });

            // Start the render loop only
            animate();
        }

        // --- Lighting ---

        function addLighting() {
            // Ambient light for general visibility
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // Directional light for shadows (from top-back)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 15, 8);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);
        }

        // --- Cake Geometry ---

        function createCake() {
            // Cake Tiers (Bottom to Top)
            const tiers = [
                { radius: 4.5, height: 3.0, y: 1.5, color: CAKE_COLORS.darkChocolate }, // Bottom
                { radius: 3.5, height: 2.5, y: 4.25, color: CAKE_COLORS.darkChocolate }, // Middle
                { radius: 2.5, height: 2.0, y: 6.5, color: CAKE_COLORS.darkChocolate }  // Top
            ];

            const material = new THREE.MeshStandardMaterial({
                color: CAKE_COLORS.darkChocolate,
                roughness: 0.7,
                metalness: 0.1
            });

            tiers.forEach((tier) => {
                const geometry = new THREE.CylinderGeometry(tier.radius, tier.radius, tier.height, 64);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = tier.y;
                mesh.receiveShadow = true;
                mesh.castShadow = true;
                scene.add(mesh);

                // Add simple icing drip effect (approximation)
                createIcingDrip(mesh, tier.radius, tier.height);

                // Add sprinkles (simple randomized dots)
                createSprinkles(mesh, tier.radius, tier.height);
            });

            // Plate
            const plateGeometry = new THREE.CylinderGeometry(6, 6, 0.5, 64);
            const plateMaterial = new THREE.MeshStandardMaterial({
                color: CAKE_COLORS.plateWhite,
                roughness: 0.1,
                metalness: 0.8
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.position.y = -0.25;
            plate.receiveShadow = true;
            scene.add(plate);
        }

        function createIcingDrip(cakeMesh, radius, height) {
            // Simple visual approximation of the icing layer on top
            const icingGeometry = new THREE.CylinderGeometry(radius, radius, 0.2, 64);
            const icingMaterial = new THREE.MeshStandardMaterial({
                color: CAKE_COLORS.icingWhite,
                roughness: 0.3,
                metalness: 0.1,
                transparent: true,
                opacity: 0.95
            });
            const icingMesh = new THREE.Mesh(icingGeometry, icingMaterial);
            icingMesh.position.copy(cakeMesh.position);
            icingMesh.position.y += height / 2; // Place on top of the tier
            icingMesh.receiveShadow = true;
            scene.add(icingMesh);
        }

        function createSprinkles(cakeMesh, radius, height) {
            const sprinkleCount = 50;
            const sprinkleMaterial = new THREE.MeshPhongMaterial({ color: CAKE_COLORS.sprinkleRed });

            for (let i = 0; i < sprinkleCount; i++) {
                const isRed = Math.random() > 0.5;
                const color = isRed ? CAKE_COLORS.sprinkleRed : CAKE_COLORS.sprinkleBlue;

                const material = new THREE.MeshPhongMaterial({ color: color });
                const geometry = new THREE.BoxGeometry(0.05, 0.2, 0.05);
                const sprinkle = new THREE.Mesh(geometry, material);

                // Random position on the top surface of the cake
                let angle = Math.random() * Math.PI * 2;
                let r = Math.random() * radius;
                sprinkle.position.x = cakeMesh.position.x + r * Math.cos(angle);
                sprinkle.position.z = cakeMesh.position.z + r * Math.sin(angle);
                sprinkle.position.y = cakeMesh.position.y + height / 2 + 0.1; // Slightly above the surface

                sprinkle.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(sprinkle);
            }
        }

        // --- Candle & Flame Geometry ---

        function createCandles() {
            const candleMaterial = new THREE.MeshPhongMaterial({
                color: CAKE_COLORS.candleGold,
                specular: 0xffffff,
                shininess: 100 // Simulate metallic/glittery gold shimmer
            });

            CANDLE_POSITIONS.forEach((pos, index) => {
                // Candle Stick (simple cylinder, slightly offset from center for better placement)
                const wickGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                const wickMesh = new THREE.Mesh(wickGeometry, candleMaterial);
                wickMesh.position.set(pos.x, 7.5 + 1.5 / 2, pos.z);
                wickMesh.castShadow = true;
                scene.add(wickMesh);

                // --- 'A' and 'Q' Approximation (Simple shape) ---
                // For simplicity and single-file mandate, we use a custom gold shape
                const letterShape = new THREE.DodecahedronGeometry(0.4); // Using a shape to represent the candle's top
                const letterMesh = new THREE.Mesh(letterShape, candleMaterial);
                letterMesh.position.set(pos.x, 8.5, pos.z);
                scene.add(letterMesh);

                // --- Flame ---
                const flameGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const flameMaterial = new THREE.MeshBasicMaterial({
                    color: CAKE_COLORS.flamePurple,
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false
                });
                const flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
                flameMesh.position.set(pos.x, 9.1, pos.z);
                scene.add(flameMesh);
                flames.push(flameMesh);

                // --- Light (for glow and flicker) ---
                const flameLight = new THREE.PointLight(CAKE_COLORS.flamePurple, 3, 5, 2);
                flameLight.position.copy(flameMesh.position);
                scene.add(flameLight);
                lights.push(flameLight);
            });
            isCandleLit = true;
        }

        // --- Particle Effects (Sparkler & Confetti) ---

        function createParticles() {
            // Sparkler Particles (Orange/Yellow - fine lines)
            const sparklerGeometry = new THREE.BufferGeometry();
            const sparklerCount = 500;
            const sparklerVertices = new Float32Array(sparklerCount * 3);
            sparklerGeometry.setAttribute('position', new THREE.BufferAttribute(sparklerVertices, 3));

            const sparklerMaterial = new THREE.PointsMaterial({
                color: 0xffa500, // Orange-gold
                size: 0.05,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0, // Hidden initially
                sizeAttenuation: true
            });

            sparklerParticles = new THREE.Points(sparklerGeometry, sparklerMaterial);
            sparklerParticles.position.y = 9;
            scene.add(sparklerParticles);
            sparklerParticles.userData.velocities = [];

            // Confetti Particles (Colorful - cubes)
            const confettiGeometry = new THREE.BufferGeometry();
            const confettiCount = 100;
            const confettiVertices = new Float32Array(confettiCount * 3);
            confettiGeometry.setAttribute('position', new THREE.BufferAttribute(confettiVertices, 3));

            const confettiMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                vertexColors: true, // Will set colors in JS
                transparent: true,
                opacity: 0, // Hidden initially
                sizeAttenuation: true
            });

            // Add colors attribute
            const colors = new Float32Array(confettiCount * 3);
            confettiGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            confettiParticles = new THREE.Points(confettiGeometry, confettiMaterial);
            confettiParticles.position.y = 9;
            scene.add(confettiParticles);
            confettiParticles.userData.velocities = [];
            confettiParticles.userData.colors = [];
        }

        function updateSparklerAndConfetti() {
            if (!hasBlownOut) return;

            const sparklerPositions = sparklerParticles.geometry.attributes.position.array;
            const sparklerVelocities = sparklerParticles.userData.velocities;

            const confettiPositions = confettiParticles.geometry.attributes.position.array;
            const confettiVelocities = confettiParticles.userData.velocities;

            const GRAVITY = -0.01;

            // Sparkler Update
            if (sparklerParticles.material.opacity > 0) {
                for (let i = 0; i < sparklerVelocities.length; i += 3) {
                    sparklerVelocities[i + 1] += GRAVITY * 0.5; // Less gravity for sparkler
                    sparklerPositions[i + 0] += sparklerVelocities[i + 0];
                    sparklerPositions[i + 1] += sparklerVelocities[i + 1];
                    sparklerPositions[i + 2] += sparklerVelocities[i + 2];
                }
                sparklerParticles.geometry.attributes.position.needsUpdate = true;
                sparklerParticles.material.opacity -= 0.005; // Fade out slowly
            }

            // Confetti Update
            if (confettiParticles.material.opacity > 0) {
                for (let i = 0; i < confettiVelocities.length; i += 3) {
                    confettiVelocities[i + 1] += GRAVITY;
                    confettiPositions[i + 0] += confettiVelocities[i + 0];
                    confettiPositions[i + 1] += confettiVelocities[i + 1];
                    confettiPositions[i + 2] += confettiVelocities[i + 2];

                    // Simple "drag" effect to slow horizontal movement
                    confettiVelocities[i + 0] *= 0.98;
                    confettiVelocities[i + 2] *= 0.98;
                }
                confettiParticles.geometry.attributes.position.needsUpdate = true;
                confettiParticles.material.opacity = Math.min(1, confettiParticles.material.opacity + 0.01);
            }
        }

        function launchParticles() {
            const COLOR_PALETTE = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];

            // --- Sparkler Launch ---
            const sparklerPositions = sparklerParticles.geometry.attributes.position.array;
            const sparklerVelocities = sparklerParticles.userData.velocities;
            sparklerVelocities.length = 0; // Clear velocities
            sparklerParticles.material.opacity = 1; // Start fully visible

            for (let i = 0; i < sparklerPositions.length; i += 3) {
                // Initial position around the candles
                sparklerPositions[i + 0] = (Math.random() - 0.5) * 1.5;
                sparklerPositions[i + 1] = 0;
                sparklerPositions[i + 2] = (Math.random() - 0.5) * 1.5;

                // Random high upward velocity (Y) and less horizontal (X, Z)
                sparklerVelocities.push((Math.random() - 0.5) * 0.05); // vx
                sparklerVelocities.push(Math.random() * 0.4 + 0.2);     // vy
                sparklerVelocities.push((Math.random() - 0.5) * 0.05); // vz
            }
            sparklerParticles.geometry.attributes.position.needsUpdate = true;

            // --- Confetti Launch ---
            const confettiPositions = confettiParticles.geometry.attributes.position.array;
            const confettiVelocities = confettiParticles.userData.velocities;
            const confettiColors = confettiParticles.geometry.attributes.color.array;
            confettiVelocities.length = 0;
            confettiParticles.material.opacity = 1;

            for (let i = 0; i < confettiPositions.length; i += 3) {
                // Initial position (centered)
                confettiPositions[i + 0] = 0;
                confettiPositions[i + 1] = 0;
                confettiPositions[i + 2] = 0;

                // Random velocity in all directions
                confettiVelocities.push((Math.random() - 0.5) * 0.2); // vx
                confettiVelocities.push(Math.random() * 0.3 + 0.1);    // vy
                confettiVelocities.push((Math.random() - 0.5) * 0.2); // vz

                // Set random color
                const color = new THREE.Color(COLOR_PALETTE[Math.floor(Math.random() * COLOR_PALETTE.length)]);
                confettiColors[i] = color.r;
                confettiColors[i + 1] = color.g;
                confettiColors[i + 2] = color.b;
            }
            confettiParticles.geometry.attributes.position.needsUpdate = true;
            confettiParticles.geometry.attributes.color.needsUpdate = true;
        }

        // --- Audio/Microphone Setup ---

        async function setupAudio() {
            try {
                // Request microphone access
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();

                analyser.fftSize = 256;
                microphone.connect(analyser);

                const micStatus = document.getElementById('mic-status');
                micStatus.textContent = "ðŸ”Š Mic Ready! Blow into your phone to blow out the candles!";
                micStatus.classList.remove('text-yellow-400');
                micStatus.classList.add('text-green-400');
                document.getElementById('loading-dots').style.display = 'none';

                // Start checking for blow event
                startAudioAnalysis();

            } catch (err) {
                console.error('Error accessing microphone:', err);
                const micStatus = document.getElementById('mic-status');
                micStatus.textContent = "Mic access denied. Tap 'Blow Out' to manually.";
                micStatus.classList.remove('text-yellow-400');
                micStatus.classList.add('text-red-400');
                document.getElementById('initial-instruction').innerHTML += '<button id="manual-blow" class="mt-4 px-6 py-2 bg-pink-500 hover:bg-pink-600 text-white font-bold rounded-full transition">Blow Out</button>';
                document.getElementById('manual-blow').addEventListener('click', blowOutCandles);
            }
        }

        function startInteraction() {
            // Remove the initial instruction and start mic setup
            document.getElementById('initial-instruction').innerHTML = `
                <p class="mb-4 text-gray-300">Setting up microphone...</p>
                <div id="mic-status" class="text-sm text-yellow-400">
                    <span id="loading-dots">
                        <span class="loading-dot">.</span><span class="loading-dot">.</span><span class="loading-dot">.</span>
                    </span>
                    Requesting access...
                </div>
                <p class="mt-4 text-3xl font-extrabold glitter-text">Happy Birthday AQ!</p>
            `;
            setupAudio();
        }

        function startAudioAnalysis() {
            const dataArray = new Uint8Array(analyser.fftSize);

            function checkBlow() {
                if (hasBlownOut) return;

                analyser.getByteTimeDomainData(dataArray); // Get waveform data

                // Calculate average volume (RMS approximation)
                let sumOfSquares = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    const value = (dataArray[i] - 128) / 128; // Normalize to -1 to 1
                    sumOfSquares += value * value;
                }
                const rms = Math.sqrt(sumOfSquares / dataArray.length) * 255; // Scale back to 0-255 range

                if (rms > BLOW_THRESHOLD) {
                    blowOutCandles();
                }

                if (!hasBlownOut) {
                    requestAnimationFrame(checkBlow);
                }
            }
            requestAnimationFrame(checkBlow);
        }

        // --- Core Game Logic ---

        function blowOutCandles() {
            if (hasBlownOut) return;
            hasBlownOut = true;
            isCandleLit = false;

            // 1. Extinguish Flames
            flames.forEach(flame => {
                // Scale down and disappear
                new THREE.Tween(flame.scale).to({ x: 0.01, y: 0.01, z: 0.01 }, 500).start();
                flame.material.opacity = 0;
            });
            lights.forEach(light => {
                light.intensity = 0;
            });

            // 2. Activate Sparkler and Confetti
            launchParticles();

            // 3. Show Birthday Message with Animation
            const instructionBox = document.getElementById('initial-instruction');
            const birthdayMessage = document.getElementById('birthday-message');

            instructionBox.style.display = 'none';
            birthdayMessage.style.display = 'block';
            setTimeout(() => {
                birthdayMessage.classList.add('active');
            }, 50);

            // Stop microphone stream (optional but good practice)
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            // Remove manual blow button if it was added
            const manualBlow = document.getElementById('manual-blow');
            if (manualBlow) {
                manualBlow.style.display = 'none';
            }
        }

        // --- Animation Loop ---

        function animate(time) {
            requestAnimationFrame(animate);

            // Candle Flicker Effect (only when lit)
            if (isCandleLit) {
                lights.forEach(light => {
                    // Purple glowing and natural flicker
                    light.intensity = 3 + Math.sin(time * 0.01 + light.uuid) * 1.5 + Math.random() * 0.5;
                });
                flames.forEach(flame => {
                    // Make the flame size fluctuate slightly
                    const scaleFactor = 1 + Math.sin(time * 0.005 + flame.uuid) * 0.1;
                    flame.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    flame.material.opacity = 0.8 + Math.random() * 0.2;
                });
            }

            // Update particle effects
            updateSparklerAndConfetti();

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- Utility Functions ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.onload = initScene;

    </script>
</body>
</html>